package routers

import (
	"context"
	"encoding/json"
	"net/http"
	"time"
	"twitta/database"
	"twitta/jwt"
	"twitta/models"

	"github.com/aws/aws-lambda-go/events"
)

func Login(ctx context.Context) models.ApiResponse { // This function handles the login request and returns a response
	var User models.User            // create a new user model
	var response models.ApiResponse // create a new response object

	body := ctx.Value(models.Key("body")).(string) // get the body of the request from the context
	err := json.Unmarshal([]byte(body), &User)     // unmarshal the body into the user model
	if err != nil {                                // if there is an error unmarshaling the body, return an error and a message
		response.Message = "Usuario y/o contraseña incorrectos " + err.Error() // set the message to the one returned by the validation function"
		return response                                                        // return the error and the message
	}

	if len(User.Email) == 0 { // check if the email is empty
		response.Message = "Email del usuario requerido" // set the message to the one returned by the validation function"
		return response                                  // return the error and the message
	}

	userData, exist := database.TryToLogin(User.Email, User.Password) // try to login the user with the email and passworda
	if !exist {                                                       // if the user does not exist, return an error and a message
		response.Message = "Usuario y/o contraseña incorrectos" // set the message to the one returned by the validation function"
		return response                                         // return the error and the message
	}

	jwtKey, err := jwt.GennerateToken(ctx, userData) // generate a token for the user

	if err != nil { // if there is an error generating the token, return an error and a message
		response.Message = "Error al generar el token > " + err.Error() // set the message to the one returned by the validation function"
	}

	responseOfLogin := models.LoginResponse{ // create a new login response object
		Token: jwtKey, // set the token to the one generated by the jwt function
	}
	token, err2 := json.Marshal(responseOfLogin) // marshal the login response object into a byte array
	if err2 != nil {                             // if there is an error marshaling the login response object, return an error and a message
		response.Message = "Ocurrio un error al intentar formar el token a JSON" // set the message to the one returned by the validation function"
	}

	coockie := &http.Cookie{ // create a new cookie object
		Name:    "token",                          // set the name of the cookie to "token"
		Value:   jwtKey,                           // set the value of the cookie to the token generated by the jwt function
		Expires: time.Now().Add((time.Hour * 24)), // set the expiration time of the cookie to 24 hours
	}

	coockieString := coockie.String() // convert the cookie to a string

	res := &events.APIGatewayProxyResponse{ // create a new API Gateway proxy response object}
		StatusCode: 200,           // set the status code to 200
		Body:       string(token), // set the body of the response to the token string
		Headers: map[string]string{ // set the headers of the response to the cookie string
			"Content-Type":                "application/json", // set the content type of the response to application/json
			"Access-Control-Allow-Origin": "*",                // set the access control allow origin header to "*"
			"Set-Cookie":                  coockieString,      // set the set-cookie header to the cookie string
		},
	}

	response.Status = 200            // set the status code to 200
	response.Message = string(token) // set the message to the token string
	response.CustomResp = res

	return response // return the response object

}
